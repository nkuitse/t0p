#!/usr/bin/perl

use strict;
use warnings;

use Digest;
use Cwd;
use File::Basename qw(basename dirname);
use File::Copy qw(move copy);
use Getopt::Long
    qw(:config posix_default gnu_compat bundling no_ignore_case);

use constant T0VERSION => 1;

sub usage;
sub fatal;

sub xopen;
sub xmkdir;
sub xchdir;
sub xmove;
sub xcopy;

my $prog = basename($0);
if ($prog eq 't0p') {
    usage if !@ARGV;
    $prog = 't0'.shift;
}

$ENV{'PATH'} = "$ENV{'PATH'}:/usr/sbin"
    if $ENV{'PATH'} !~ m{(^|:)/usr/sbin(:|$)};

my $root = $ENV{'T0P_ROOT'} ||= '/var/local/t0p';
my ($drive, $tape, $device, $queue, $block_size, $verbose, $dryrun);
my (%props);
my (%label, %status);
my @tmp;  # Anything that should be deleted when we exit
my @common_options = (
    'd=s' => \$drive,
    't=s' => \$tape,
    'q=s' => \$queue,
    'b=i' => \$block_size,
    'v'   => \$verbose,
    'n'   => \$dryrun,
);

(my $cmd = $prog) =~ s/^t0// or fatal "bizarre invocation: $prog";
&{ __PACKAGE__->can('prog_'.$cmd) || fatal "unrecognized invocation: $cmd" };

# Subprograms

sub prog_queue {
    my ($add, $create, $list, $symlink);
    GetOptions(
        @common_options,
        'a' => \$add,
        'c' => \$create,
        'l' => \$list,
        's' => \$symlink,
    ) or usage;
    init_defaults();
    $list = 1 if !$add && !$create;
    if ($list) {
        usage '-l [-q QUEUE]' if @ARGV;
        my @jobs = jobs_in_queue();
        print $_, "\n" for @jobs;
    }
    elsif ($add) {
        usage '-a [-q QUEUE] [-s] JOB' if !@ARGV;
        my $j = shift @ARGV;
        my $jdir = jdir($j);
        fatal "no such job: $j" if !-d $jdir;
        my @b = batches_in_job($jdir, 'b');
        fatal "no unprocessed batches in job $j" if !@b;
        xmkdir "$jdir/\@ready";
        xmove $jdir, "$queue/$j";
    }
    elsif ($create) {
        usage '-c -q QUEUE' if !@ARGV;
        fatal 'not yet implemented: -c';
    }
}

sub jdir { "$root/job/" . shift }

sub prog_job {
    my ($add, $create, $list, %prop);
    my $type = 'w';
    GetOptions(
        @common_options,
        'a' => \$add,
        'c' => \$create,
        'l' => \$list,
        'r' => sub { $type = 'r' },
        'p=s' => sub {
            usage if $_[1] !~ /^([^=]+)=(.*)$/;
            $prop{$1} = $2;
        },
    ) or usage;
    init_defaults();
    if ($create) {
        # Create a new job
        usage if @ARGV;
        my $j = uuid();
        my $jdir = "$root/job/$j";
        xmkdir $jdir;
        my $jfile = "$jdir/${type}job";
        write_job($jfile, {
            job => $j,
            created => time,
            type => $type,
            %prop,
        });
        print $j, "\n";
    }
    elsif ($add) {
        # Add a batch of files to an existing job
        usage 't0job -a [-p PROP=VALUE]... JOBDIR [FILE... | < MANIFEST]' if !@ARGV;
        my $jdir = shift @ARGV;
        $jdir = "$root/job/$jdir" if $jdir !~ m{^/};
        my $j = basename($jdir);
        my @files = @ARGV ? @ARGV : <STDIN>;
        fatal "no files to append to job $j" if !@files;
        chomp @files;
        my $batch = 0;
        my $jfile = "$jdir/${type}job";
        my $jfh = xopen('+>>', $jfile);
        seek $jfh, 0, 0 or fatal "seek $jfile: $!";
        while (<$jfh>) {
            next if !/^%batches$/;
            while (<$jfh>) {
                $batch = $1 + 1 if /^([0-9]+) / && $1 >= $batch;
            }
            last;
        }
        my $t0 = time;
        my $num = scalar @files;
        my $size = size_total(@files);
        print $jfh "$batch count $num size $size\n";
        my $bfh = xopen '>', "$jdir/b$batch";
        print $bfh <<"EOS";
%batch
number $batch
created $t0
size $size
count $num
EOS
        print $bfh $_, ' ', $prop{$_}, "\n" for sort keys %prop;
        print $bfh $_, "\n" for '', '%files', @files, '';
    }
    elsif ($list) {
        print "Q $_\n" for jobs_in_queue();
        print "- $_\n" for jobs_not_in_queue();
    }
}

sub prog_label {
    my ($check, $write, $force, $use_hash, $prop);
    GetOptions(
        @common_options,
        'k' => \$check,
        'w' => \$write,
        'f' => \$force,
        'h' => \$use_hash,
        'p=s' => \$prop,
    ) or usage;
    init_defaults();
    read_label();
    my ($label, $hash) = @label{qw(label hash)};
    if ($check) {
        usage if @ARGV != 1;
        my ($expected, $found) = @ARGV;
        my $blather;
        if ($use_hash) {
            ($found, $blather) = ($hash, "hash $hash");
        }
        elsif ($prop) {
            my ($p, $pval) = ($prop, $label{$prop});
            ($found, $blather) = ($pval, join(' ', $p, $pval // '[undefined]'));
        }
        else {
            ($found, $blather) = ($label, $label);
        }
        if (!defined $found) {
            print STDERR "unrecognized label (hash $hash)\n" if $verbose;
            exit 2;
        }
        elsif ($found ne $expected) {
            print STDERR "wrong label: found $blather\n" if $verbose;
            exit 2;
        }
        else {
            print STDERR "verified: $blather\n" if $verbose;
        }
    }
    elsif ($write) {
        usage if @ARGV < 1;
        if (defined($label) && !$force) {
            print STDERR "found label $label (hash $hash), use -f to force relabel\n";
            exit 2 if !$dryrun;
        }
        my $label = shift @ARGV;
        %label = (
            label => $label,
            ( map { /^([^=]+)=(.*)$/ or usage; $1 => $2 } @ARGV ),
        );
        write_label();
    }
    else {
        if (!defined $label{label}) {
            print STDERR "unrecognized label\n";
            exit 2;
        }
        elsif ($verbose) {
            print "label: $label{label}\n",
                "hash: $label{hash}\n",
                "t0version: $label{t0version}\n";
            if (keys(%label) > 2) {
                foreach (sort keys %label) {
                    next if /^(label|hash|t0version)$/;
                    printf "%s: %s\n", $_, $label{$_};
                }
            }
        }
        elsif ($use_hash) {
            print $label{hash}, "\n";
        }
        elsif ($prop) {
            my $pval = $label{$prop} // '[undefined]';
            print $pval, "\n";
        }
        else {
            print $label{label}, "\n";
        }
    }
}

sub xopen {
    my ($mode, $file) = @_;
    open my $fh, $mode, $file or fatal "open $mode $file: $!";
    return $fh;
}

sub xmkdir {
    foreach (@_) {
        mkdir $_ or fatal "mkdir: $_";
    }
}

sub xchdir {
    my ($dir) = @_;
    chdir $dir or fatal "chdir $dir: $!";
}

sub xmove {
    move($_[0], $_[1]) or fatal "move $_[0] $_[1]: $!";
}

sub xcopy {
    copy($_[0], $_[1]) or fatal "copy $_[0] $_[1]: $!";
}

sub prog_write {
    # usage: t0write [-y FILE] [ -a | JOB BATCH... ]
    my ($all, $receipt);
    GetOptions(
        @common_options,
        'a' => \$all,
        'n' => \$dryrun,
        'y' => \$receipt,
    ) or usage;
    $device = '/dev/null' if $dryrun;
    init_defaults();
    my @job_dirs;
    if ($all) {
        usage 'write [ -a | JOB BATCH... ]' if @ARGV;
        @job_dirs = map { "$queue/$_" } jobs_in_queue();
    }
    else {
        usage 'write [ -a | JOB BATCH... ]' if @ARGV < 1;
        @job_dirs = map { "$queue/$_" } @ARGV;
    }
    xmove "$drive/\@idle", "$drive/\@busy" if !$dryrun;
    foreach my $jdir (@job_dirs) {
        my $j = basename($jdir);
        my @b = batches_in_job($jdir, 'b');
        next if !@b;
        my $job = read_job("$jdir/wjob");
        if (!$dryrun) {
            xmove "$jdir/\@ready", "$jdir/\@busy";
            read_label() if !%label;
        }
        procwbatches($job, @b);
        if (!$dryrun) {
            xmove "$jdir/\@busy", "$jdir/\@done";
            xmove $jdir, "$root/job/archive/$j";
            xcopy "$jdir/log", $receipt if defined $receipt;
        }
    }
    xmove "$drive/\@busy", "$drive/\@idle" if !$dryrun;
}

sub prog_stat {
    # usage: t0stat [-v] [DRIVE]
    GetOptions(
        @common_options,
    ) or usage;
    init_defaults();
    get_status();
    printf <<'EOS', $drive, readlink($device);
drive        : %s
device       : %s
EOS
    if ($status{online}) {
        my @flags;
        foreach (qw(bot eof eod)) {
            push @flags, $_ if $status{$_};
        }
        @flags = ('--') if !@flags;
        printf <<'EOS', @status{qw(filenum partition blocksize blocknum)}, join(',',@flags);
online       : yes
file number  : %d
partition    : %d
block size   : %d
block number : %d
flags        : %s
EOS
    }
    else {
        printf <<'EOS', @status{qw(blocksize)};
online       : no
block size   : %d
EOS
    }
}

# --- Functions

sub read_job {
    my ($jfile) = @_;
    my $jfh = xopen '<', $jfile;
    my %job = ( file => $jfile, dir => dirname($jfile) );
LOOP:
    while (<$jfh>) {
        if (/^%job$/) {
            while (<$jfh>) {
                last LOOP if /^$/;
                $job{$1} = $2 if /^(\S+) (.*)/;
            }
        }
    }
    return \%job;
}

sub write_job {
    my ($jfile, $job) = @_;
    my %job = %$job;
    my $j = delete $job{job};
    my $jfh = xopen '>', $jfile;
    print $jfh <<"EOS";
%job
job $j
EOS
    print $jfh $_, ' ', $job{$_}, "\n" for sort keys %job;
    print $jfh "\n%batches\n";
    close $jfh;
}

sub size_total {
    my $size = 0;
    foreach (@_) {
        next if ! -f;
        $size += -s _;
    }
    return $size;
}

sub usage {
    print STDERR "usage: $prog $_\n" if @_;
    print STDERR "usage: $prog [OPTION...] [ARG...]}}\n" if !@_;
    exit 1;
}

sub fatal {
    print STDERR "$prog: ", $_, "\n" for @_;
    exit 2;
}

sub init_defaults {
    $drive //= readlink("$root/drive/default");
    $drive = "$root/drive/$drive" if $drive !~ m{^/};
    $device //= -e "$drive/device" ? "$drive/device" : '/dev/nst0';
    $block_size //= 32768;
    return if defined $queue && $queue =~ m{^/};
    $queue = defined $queue ? "$drive/queue/$queue" : "$drive/queue";
}

sub mt {
    open my $fh, '-|', 'mt', '-f', $device, @_ or fatal "mt: $!";
    return $fh;
}

sub tapeinfo {
    open my $fh, '-|', 'tapeinfo', '-f', $device or fatal "tapeinfo: $!";
    return $fh;
}

sub get_status {
    return %status = (
        filenum => 0,
        blocknum => 0,
        partition => 0,
        online => 1,
        eod => 1,
        eof => 0,
        bot => 1,
        blocksize => $block_size,
    ) if $dryrun;
    my $fh = mt('status');
    while (<$fh>) {
        $status{filenum}   = $1 if /file number[=: ]+([0-9]+)/i;
        $status{blocknum}  = $1 if /block number[=: ]+(-?[0-9]+)/i;
        $status{partition} = $1 if /partition[=: ]+([0-9]+)/i;
        $status{online}    = 1  if /\bONLINE\b/i;
        $status{eod}       = 1  if /\bEOD\b/i;
        $status{eof}       = 1  if /\bEOF\b/i;
        $status{bot}       = 1  if /\bBOT\b/i;
        $status{blocksize} = $1 if /block size[=: ]+([0-9]+)/i;
    }
    close $fh or fatal "mt status: $!";
    $fh = tapeinfo();
    while (<$fh>) {
        $status{position}  = $1 if /block position[=: ]+([0-9]+)/i;
    }
    close $fh or fatal "tapeinfo: $!";
}

sub read_label {
    mt('rewind') or fatal "mt rewind: $!";
    my $fh = xopen '<', $device;
    my $read = read($fh, my $buf, $block_size)
        or fatal "read label: $!";
    close $fh;
    %label = ();
    if ($buf =~ /^\At0version:([0-9])\nlabel:([^\n\0]+)\n([^\0]*)\0*\z/) {
        %label = (
            t0version => $1,
            label => $2,
            map { split /:/, $_, 2 } split /\n/, $3
        );
    }
    my $sha256 = Digest->new('SHA-256');
    $sha256->add(substr($buf, 0, 2048));
    $label{hash} = $sha256->hexdigest;
}

sub write_label {
    my $label = $label{label};
    my $fh;
    if (!$dryrun) {
        mt('rewind') or fatal "rewind: $!";
        $fh = xopen '>', $device;
    }
    my $buf = "\x00" x $block_size;
    my $str = sprintf("t0version:%d\nlabel:%s\ncreated:%s\n", T0VERSION, $label, time);
    foreach (sort keys %label) {
        next if /^(label|t0version)$/;
        $str .= sprintf("%s:%s\n", $_, $label{$_});
    }
    substr($buf, 0, length $str) = $str;
    my $sha256 = Digest->new('SHA-256');
    $sha256->add($buf);
    my $hash = $sha256->hexdigest;
    if ($dryrun) {
        print STDERR "label that would be written (hash $hash):\n", $str;
    }
    else {
        syswrite($fh, $buf) or fatal "write: $!";
        xclose $fh;
        mt('weof') or fatal "weof: $!";
        return if !$verbose;
        print STDERR "label written: $label (hash $hash)\n";
    }
}

sub read_manifest {
    my ($f) = @_;
    fatal "empty manifest: $f" if !-s $f;
    my $fh = xopen '<', $f;
    my @files = <$fh>;
    fatal "read manifest: $f" if !@files;
    chomp @files;
    return @files;
}

sub procwbatches {
    my ($job, @b) = @_;
    my $j = $job->{job};
    get_status();
    if (!$dryrun) {
        $status{online} or fatal "no tape\n";
        mt('eod');
        get_status();
        $status{eod} or fatal "not EOD\n";
        $job->{drive} = basename($drive);
        $job->{device} = $device;
    }
    my $jdir = $job->{dir};
    my $logfh = $dryrun ? \*STDERR : xopen '>>', "$jdir/log";
    my $jfile = "$jdir/wjob";
    # cd job root
    my $cwd = cwd;
    my $dir = $job->{root} // '/';
    $dir =~ m{^/} or fatal "relative job root: $dir";
    xchdir $dir;
    printf $logfh "J %s begin %d\n", $j, time;
    foreach my $b (@b) {
        procwbatch($job, $logfh, "$jdir/$b");
    }
    get_status();
    printf $logfh "T %s position %d filenum %d\n", $tape // '?', $status{position}, $status{filenum};
    printf $logfh "J %s end %d\n", $j, time;
    xchdir $cwd;
}

sub unique {
    my (%seen, @unique);
    foreach (@_) {
        push @unique, $_ if !$seen{$_}++;
    }
    return @unique;
}

sub read_batch {
    my ($f) = @_;
    my $b = basename($f);
    my @files;
    my %batch = (
        batch => $b,
        number => substr($b, 1),
        tape => '?',
        filenum => '?',
        errors => 0,
        files => \@files,
    );
    my $bfh = xopen '<', $f;
    while (<$bfh>) {
        next if /^%batch$/;
        last if /^$/;
        next if /^\s*(?:#.*)?$/;
        fatal "read batch file $f: unrecognized line: $_"
            if !/^(\S+) (.*)$/;
        $batch{$1} = $2;
    }
    while (<$bfh>) {
        next if /^%files$/;
        last if /^$/;
        chomp;
        push @files, $_;
    }
    $batch{tape} = $tape if defined $tape;
    return \%batch;
}

sub procwbatch {
    my ($job, $logfh, $bfile) = @_;
    my $jdir = dirname($bfile);
    my $batch = read_batch($bfile);
    my $n = $batch->{number};
    my ($afile, $wfile) = map { "$jdir/$_$n" } qw(@ w);

    # Build the manifest
    my @files = ("$jdir/wjob");
    if ($dryrun) {
        push @files, $bfile;
    }
    else {
        # Rename bn ---> @n
        xmove $bfile, $afile;
        push @files, $afile;
    }
    push @files, @{ $batch->{files} };
    printf $logfh "B %d begin %d files %d\n", $n, time, scalar(@files);
    my $manifest = mktmp(manifest => @files);

    # Write the archive
    get_status();
    my $pos = $status{position};
    my %fail = map { $_ => 1 } @files;
    printf $logfh "T %s position %d filenum %d\n", $tape // '?', $pos, $status{filenum};
    open my $fhafio, "afio -o -A -b $block_size -v -B $device < $manifest 2>&1 |"
        or fatal "exec afio: $!";
    while (<$fhafio>) {
        if (/^([0-9]+) (.+) -- okay$/) {
            printf $logfh "F %d %s\n", $1, $2;
            delete $fail{$2};
        }
        else {
            print $logfh '* ', $_;
        }
    }
    unlink $manifest;
    close $fhafio or fatal "afio: $!";

    # Log any failed files
    print $logfh "E $_\n" for sort keys %fail;

    # Rename @n ---> wn
    xmove $afile, $wfile if !$dryrun;
    get_status();
    printf $logfh "B %d end %d blocks %d errors %d\n", $n, time, $status{position} - $pos, scalar keys %fail;
}

sub mktmp {
    my $type = shift;
    my $f = qx{mktemp -t t0p.$$.$type.XXXXXX};
    chomp $f;
    my $fh = xopen '>', $f;
    print $fh $_, "\n" for @_;
    close $fh;
    push @tmp, $f;
    return $f;
}

sub jobs_not_in_queue {
    my @jobs;
    foreach (glob("$root/job/*/?job")) {
        my @parts = split '/';
        pop @parts;
        my $job = pop @parts;
        push @jobs, $job;
    }
    return @jobs;
}

sub jobs_in_queue {
    my @job_statuses = glob("$queue/*/\@*");
    my @jobs;
    foreach (@job_statuses) {
        my @parts = split '/';
        my $status = pop @parts;
        my $job = pop @parts;
        push @jobs, $job;
    }
    return @jobs;
}

sub batches_in_job {
    my $job = shift;
    my %want = map { $_ => 1 } @_;
    %want = qw(b 1 r 1 w 1) if !@_;
    my %batch;
    foreach (glob("$job/*")) {
        next if !m{.+/([bwr])([0-9]+)$};
        $batch{$1.$2} = $1 if $want{$1};
    }
    return wantarray ? keys %batch : \%batch;
}

sub uuid {
    my $uuid = qx(uuidgen);
    chomp $uuid;
    return $uuid;
}

