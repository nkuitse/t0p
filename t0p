#!/usr/bin/perl

use strict;
use warnings;

use Digest;
use Cwd;
use File::Basename qw(basename dirname);
use File::Copy qw(move copy);
use POSIX qw(strftime);
use Getopt::Long
    qw(:config posix_default gnu_compat bundling no_ignore_case);

use constant T0VERSION => 1;
use constant DEFBLKSIZE => 32768;

sub usage;
sub fatal;

sub xopen;
sub xmkdir;
sub xchdir;
sub xmove;
sub xcopy;
sub xsymlink;
sub xunlink;

my $prog = basename($0);
if ($prog eq 't0p') {
    usage if !@ARGV;
    $prog = 't0'.shift;
}

$ENV{'PATH'} = "$ENV{'PATH'}:/usr/sbin"
    if $ENV{'PATH'} !~ m{(^|:)/usr/sbin(:|$)};

my $root = $ENV{'T0P_ROOT'} ||= '/var/local/t0p';
my ($drive, $tape, $device, $queue, $block_size, $verbose, $dryrun);
my (%props);
my (%label, %status);
my %type2human = qw(w write r read);
my @tmp;  # Anything that should be deleted when we exit
my @common_options = (
    'd=s' => \$drive,
    't=s' => \$tape,
    'q=s' => \$queue,
    'b=i' => \$block_size,
    'v'   => \$verbose,
    'n'   => \$dryrun,
);

my $ok = eval {
    (my $cmd = $prog) =~ s/^t0// or usage;
    &{ __PACKAGE__->can('prog_'.$cmd) || usage };
    1;
};
if (!$ok) {
    exit 2;
}

# Subprograms

sub prog_queue {
    my ($add, $create, $list);
    GetOptions(
        @common_options,
        'a' => \$add,
        'c' => \$create,
        'l' => \$list,
    ) or usage;
    init_defaults();
    $list = 1 if !$add && !$create;
    if ($list) {
        usage '-l [-q QUEUE]' if @ARGV;
        my @jobs = jobs_in_queue();
        print $_, "\n" for @jobs;
    }
    elsif ($add) {
        usage '-a [-q QUEUE] JOB...' if !@ARGV;
        my @oops = grep { status(jdir($_)) ne 'unknown' } @ARGV;
        fatal "already queued or processed: @oops" if @oops;
        foreach my $j (@ARGV) {
            add_job_to_queue($j);
        }
    }
    elsif ($create) {
        usage '-c -q QUEUE' if !@ARGV;
        fatal 'not yet implemented: -c';
    }
}

sub prog_job {
    my ($add, $create, $list, $clone, $revoke, $redo, %prop);
    my $type = 'w';
    GetOptions(
        @common_options,
        'a' => \$add,
        'c' => \$create,
        'l' => \$list,
        'clone' => \$clone,
        'revoke' => \$revoke,
        'redo' => \$redo,
        'r' => sub { $type = 'r' },
        'p=s' => sub {
            usage if $_[1] !~ /^([^=]+)=(.*)$/;
            $prop{$1} = $2;
        },
    ) or usage;
    usage if scalar(grep { defined $_ } $add, $create, $list, $clone, $revoke, $redo) > 1;
    init_defaults();
    if ($create) {
        # Create a new job
        usage if @ARGV;
        my $j = uuid();
        my $jdir = "$root/job/$j";
        xmkdir $jdir;
        my $jfile = "$jdir/${type}job";
        write_job($jfile, {
            job => $j,
            created => time,
            type => $type,
            %prop,
        });
        print $j, "\n";
    }
    elsif ($add) {
        # Add a batch of files to an existing job
        usage 't0job -a [-p PROP=VALUE]... JOBDIR [FILE... | < MANIFEST]' if !@ARGV;
        my $jdir = shift @ARGV;
        $jdir = "$root/job/$jdir" if $jdir !~ m{^/};
        my $j = basename($jdir);
        my @files = @ARGV ? @ARGV : <STDIN>;
        fatal "no files to append to job $j" if !@files;
        chomp @files;
        my $batch = 0;
        my $jfile = "$jdir/${type}job";
        my $jfh = xopen('+>>', $jfile);
        seek $jfh, 0, 0 or fatal "seek $jfile: $!";
        while (<$jfh>) {
            next if !/^%batches$/;
            while (<$jfh>) {
                $batch = $1 + 1 if /^([0-9]+) / && $1 >= $batch;
            }
            last;
        }
        my $t0 = time;
        my $num = scalar @files;
        my $size = size_total(@files);
        print $jfh "$batch count $num size $size\n";
        my $bfh = xopen '>', "$jdir/b$batch";
        print $bfh <<"EOS";
%batch
number $batch
created $t0
size $size
count $num
EOS
        print $bfh $_, ' ', $prop{$_}, "\n" for sort keys %prop;
        print $bfh $_, "\n" for '', '%files', @files, '';
    }
    elsif ($list) {
        my (%jdir, %job, %ctime);
        $verbose = 1 if @ARGV;
        my @j = @ARGV ? @ARGV : jobs();
        foreach my $j (@j) {
            my $job = $job{$j} = read_job( $jdir{$j} = jdir($j) );
            $ctime{$j} = strftime '%Y-%m-%d %H:%M:%S', localtime $job->{created};
        }
        @j = sort { $ctime{$a} cmp $ctime{$b} } @j if !@ARGV;
        my %skip = $verbose ? () : qw(done 1 revoked 1);
        foreach my $j (@j) {
            my $jdir = $jdir{$j};
            my $status = status($jdir);
            next if $skip{$status};
            my $type = job_type($j);
            my $job = read_job("${jdir}/${type}job");
            my $root = $job->{root} // '?';
            printf "%-7.7s %5.5s %s %s %s\n", $status, $type2human{$type}, $j, $ctime{$j}, $root;
        }
    }
    elsif ($clone) {
        usage if !@ARGV;
        foreach my $j (@ARGV) {
            print clone_job($j), "\n";
        }
    }
    elsif ($revoke) {
        usage if !@ARGV;
        my @oops = grep { status(jdir($_)) ne 'done' } @ARGV;
        fatal "can't be revoked: @oops" if @oops;
        foreach my $j (@ARGV) {
            revoke_job($j);
        }
    }
    elsif ($redo) {
        usage if !@ARGV;
        my @clones;
        my @oops = grep { status(jdir($_)) ne 'done' } @ARGV;
        fatal "can't be done @oops" if @oops;
        foreach my $j (@ARGV) {
            my $clonej = clone_job($j);
            print STDERR "$j -> $clonej";
            revoke_job($j);
            add_job_to_queue($clonej);
        }
    }
}

sub set_status {
    my ($dir, $from, $to) = @_;
    $from = status($dir) if $from eq '*';
    xmove "$dir/\@$from", "$dir/\@$to";
}

sub status {
    my ($dir) = @_;
    my @stat = glob("$dir/\@*");
    return 'unknown' if !@stat;
    return 'multiple' if @stat > 1;
    return substr(basename($stat[0]), 1);
}

sub prog_label {
    my ($check, $write, $force, $use_hash, $prop);
    GetOptions(
        @common_options,
        'k' => \$check,
        'w' => \$write,
        'f' => \$force,
        'h' => \$use_hash,
        'p=s' => \$prop,
    ) or usage;
    init_defaults();
    read_label();
    my ($label, $hash) = @label{qw(label hash)};
    if ($check) {
        usage if @ARGV != 1;
        my ($expected, $found) = @ARGV;
        my $blather;
        if ($use_hash) {
            ($found, $blather) = ($hash, "hash $hash");
        }
        elsif ($prop) {
            my ($p, $pval) = ($prop, $label{$prop});
            ($found, $blather) = ($pval, join(' ', $p, $pval // '[undefined]'));
        }
        else {
            ($found, $blather) = ($label, $label);
        }
        if (!defined $found) {
            print STDERR "unrecognized label (hash $hash)\n" if $verbose;
            exit 2;
        }
        elsif ($found ne $expected) {
            print STDERR "wrong label: found $blather\n" if $verbose;
            exit 2;
        }
        else {
            print STDERR "verified: $blather\n" if $verbose;
        }
    }
    elsif ($write) {
        usage if @ARGV < 1;
        if (defined($label) && !$force) {
            print STDERR "found label $label (hash $hash), use -f to force relabel\n";
            exit 2 if !$dryrun;
        }
        my $label = shift @ARGV;
        %label = (
            label => $label,
            ( map { /^([^=]+)=(.*)$/ or usage; $1 => $2 } @ARGV ),
        );
        write_label();
    }
    else {
        if (!defined $label{label}) {
            print STDERR "unrecognized label\n";
            exit 2;
        }
        elsif ($verbose) {
            print "label: $label{label}\n",
                "hash: $label{hash}\n",
                "t0version: $label{t0version}\n";
            if (keys(%label) > 2) {
                foreach (sort keys %label) {
                    next if /^(label|hash|t0version)$/;
                    printf "%s: %s\n", $_, $label{$_};
                }
            }
        }
        elsif ($use_hash) {
            print $label{hash}, "\n";
        }
        elsif ($prop) {
            my $pval = $label{$prop} // '[undefined]';
            print $pval, "\n";
        }
        else {
            print $label{label}, "\n";
        }
    }
}

sub prog_write {
    # usage: t0write [-y FILE] [ -a | JOB BATCH... ]
    my ($all, $receipt);
    GetOptions(
        @common_options,
        'a' => \$all,
        'n' => \$dryrun,
        'y=s' => \$receipt,
    ) or usage;
    $device = '/dev/null' if $dryrun;
    init_defaults();
    my @job_dirs;
    if ($all) {
        usage 'write [ -a | JOB BATCH... ]' if @ARGV;
        @job_dirs = map { "$queue/$_" } jobs_in_queue();
    }
    else {
        usage 'write [ -a | JOB BATCH... ]' if @ARGV < 1;
        @job_dirs = map { "$queue/$_" } @ARGV;
    }
    if (!@job_dirs) {
        print STDERR "no jobs to write\n" if $verbose;
        exit 0;
    }
    if (!$dryrun) {
        set_status("$drive/tape", 'loaded' => 'busy');
        set_status($drive, 'idle' => 'busy');
        read_label("$drive/tape/\@busy/../label")
            if -e "$drive/tape/\@busy/../label";
    }
    foreach my $jlink (@job_dirs) {
        my $jdir = readlink $jlink;
        my $j = basename($jdir);
        my @b = batches_in_job($jdir, 'b');
        next if !@b;
        my $job = read_job("$jdir/wjob");
        my $job_receipt = $receipt // $job->{receipt};
        if (!$dryrun) {
            set_status($jdir, 'ready' => 'busy');
            read_label() if !%label;
        }
        procwbatches($job, @b);
        if (!$dryrun) {
            set_status($jdir, 'busy' => 'done');
            xunlink $jlink;
            if (defined $job_receipt) {
                xcat(
                    xopen('<', "$jdir/wjob"),
                    "\n%log\n",
                    xopen('<', "$jdir/log"),
                    "\n",
                    '>>', $job_receipt
                );
            }
        }
    }
    if (!$dryrun) {
        set_status("$drive/tape", 'busy' => 'loaded');
        set_status($drive, 'busy' => 'idle');
    }
}

sub prog_stat {
    # usage: t0stat [-v] [DRIVE]
    GetOptions(
        @common_options,
    ) or usage;
    init_defaults();
    get_status();
    printf <<'EOS', basename($drive), readlink($device);
drive         : %s
device        : %s
EOS
    if ($status{online}) {
        my @flags;
        foreach (qw(bot eof eod)) {
            push @flags, $_ if $status{$_};
        }
        @flags = ('--') if !@flags;
        printf <<'EOS', $tape // '?', @status{qw(blocksize filenum file_blocknum position)}, join(',',@flags);
online        : yes
tape          : %s
block size    : %d
file number   : %d
block in file : %d
block on tape : %d
flags         : %s
EOS
    }
    else {
        printf <<'EOS', @status{qw(blocksize)};
online        : no
block size    : %d
EOS
    }
}

sub prog_scan {
    my $include_label;
    GetOptions(
        @common_options,
        'l' => \$include_label,
    ) or usage;
    usage if @ARGV > 1;
    my $maxfiles = @ARGV ? shift @ARGV: 1;
    init_defaults();
    printf "%8.8s %8.8s %-5.5s %s\n", qw(Filenum Position Batch Job);
    if ($include_label) {
        read_label();
        printf "%8d %8d %-5.5s %s (hash=%s)\n", 0, 0, 'LABEL', $label{label} // '?', $label{hash};
    }
    get_status();
    while (1) {
        mt('fsf'), get_status() if $status{file_blocknum} != 0;
        my @output = qx{afio -t -A -b $block_size -v -B $device 2> /dev/null};
        last if $?;
        print("EOF\n"), last if !@output;
        my ($j, $b) = map {
            m:/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/\@([0-9]+):
                ? ($1, $2) : ()
        } @output;
        if (defined $j) {
            printf "%8d %8d %5d %s\n", $status{filenum}, $status{position}, $b, $j;
        }
        else {
            printf "%8d %8d %-5.5s %s", $status{filenum}, $status{position}, '?', $output[0];
        }
        last if defined $maxfiles && !--$maxfiles;
        get_status();
    }
    get_status();
    print "EOD\n" if $status{eod};
}

sub prog_seek {
    my ($eod, $filenum, $file_blocknum);
    Getopt::Long::Configure('pass_through');
    GetOptions(
        @common_options,
        'e' => \$eod,
    );
    if ($eod) {
        usage if @ARGV;
        init_defaults();
        return mt('eod');
    }
    usage if @ARGV < 1 || @ARGV > 2;
    ($filenum, $file_blocknum) = @ARGV;
    $file_blocknum = 0 if !defined $file_blocknum;
    $filenum = '+0' if $filenum eq '.';
    $file_blocknum = '+0' if $file_blocknum eq '.';
    init_defaults();
    get_status();
    $filenum += $status{filenum} if $filenum =~ /^[-+]/;
    $file_blocknum += $status{file_blocknum} if $file_blocknum =~ /^[-+]/;
    # Go to the desired file
    if ($filenum > $status{filenum}) {
        mt('fsf', $filenum - $status{filenum});
    }
    elsif ($filenum == $status{filenum}) {
        # Nothing to do
    }
    elsif ($filenum < $status{filenum} / 3) {
        # Heuristic: if we have to go back more than 2/3 of the way to the
        # beginning of the tape, just rewind and seek forward.  This makes
        # sense if fsf and bsf are equally fast and rewinding is twice as fast.
        mt('asf', $filenum);
    }
    else {
        my $diff = $status{filenum} - $filenum;
        mt('bsfm', $diff + 1);
    }
    # Go to the desired block within the file
    if (defined $file_blocknum) {
        get_status();
        if ($status{file_blocknum} < 0 || $file_blocknum < $status{file_blocknum}) {
            mt('bsfm', 1);
            get_status();
        }
        if ($file_blocknum > $status{file_blocknum}) {
            file_block_fwd($file_blocknum - $status{file_blocknum});
        }
    }
}

sub prog_tell {
    my (@what, $restore_pos);
    GetOptions(
        @common_options,
        'f' => sub { push @what, qw(filenum) },
        'b' => sub { push @what, qw(file_blocknum) },
        'p' => sub { push @what, qw(position) },
        'j' => sub { push @what, qw(job batch) },
        'r' => \$restore_pos,
    ) or usage;
    @what = qw(filenum) if !@what;
    my $fmt = join(' ', map { '%s' } @what) . "\n";
    init_defaults();
    get_status();
    if (grep { $_ eq 'job' } @what) {
        my @output = qx{afio -t -A -b $block_size -v -B $device 2> /dev/null};
        my ($j, $b) = map {
            m:/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/\@([0-9]+):
                ? ($1, $2) : ()
        } @output;
        fatal "tell: not a t0p batch, or positioned wrong" if !defined $j;
        @status{qw(job batch)} = ($j, $b);
        if ($restore_pos) {
            @ARGV = @status{qw(filenum file_blocknum)};
            prog_seek();
        }
    }
    printf $fmt, @status{@what};
}

sub prog_read {
    GetOptions(
        @common_options,
    ) or usage;
    init_defaults();
    get_status();
    my $fh = xopen('<', $device);
    my $buf = '';
    $| = 1;
    if (@ARGV) {
        my ($num_blocks) = @ARGV;
        while (read_block($fh, \$buf)) {
            print $buf;
            last if --$num_blocks == 0;
        }
        fatal "read: unexpected EOF" if $num_blocks != 0;
    }
    else {
        while (read_block($fh, \$buf)) {
            print $buf;
        }
    }
}

sub prog_reset {
    GetOptions(
        @common_options,
    ) or usage;
    init_defaults();
    mt('setblk', $block_size);
    mt('rewind');
    mt('eod');
}

sub prog_find {
    my ($long, $all, $regexp);
    GetOptions(
        @common_options,
        'l|long' => \$long,
        'a|all-jobs' => \$all,
        'm|match=s' => \$regexp,
    ) or usage;
    init_defaults();
    my (@j, $filter);
    if (defined $regexp) {
        # t0find -m REGEXP [-a | JOB...]
        my $rx = qr/$regexp/;
        if ($all) {
            usage if @ARGV;
            @j = jobs();
        }
        else {
            usage if !@ARGV;
            @j = @ARGV;
        }
        $filter = sub { $_ =~ $rx };
    }
    else {
        # t0find [-a | JOB] FILE...
        if ($all) {
            usage if @ARGV < 1;
            @j = jobs();
        }
        else {
            usage if @ARGV < 2;
            @j = shift @ARGV;
        }
        my %want = map { $_ => 1 } @ARGV;
        $filter = sub { $want{$_} };
    }
    printf "%-7.7s %7.7s %7.7s %s\n", qw(Tape Filenum Offset File) if $long;
    my $nf = 0;
    foreach my $j (@j) {
        my $jdir = jdir($j);
        my $job = eval { read_job("$jdir/wjob") };
        next if !defined $job;
        my $log = read_log("$jdir/log");
        my $file2loc = $log->{files};
        my @files = grep { $filter->() } keys %$file2loc;
        foreach my $f (@files) {
            my $loc = $file2loc->{$f};
            if ($long) {
                printf "%-7.7s %7d %7d %s\n", @$loc, $f;
            }
            else {
                print join(' ', @$loc[0,1], $f), "\n";
            }
        }
        $nf += scalar @files;
    }
    exit $nf ? 2 : 0;
}

sub prog_tapes {
    my $long;
    GetOptions(
        @common_options,
        'l|long' => \$long,
    ) or usage;
    init_defaults();
    my @tapes = grep { -d $_ } glob("$root/tape/*");
    printf "%-6.6s %-7.7s %8.8s %8.8s %7.7s %6.6s\n", qw(Tape Status Capacity Used Files Avail%);
    my %jb2size;
    foreach my $tp (@tapes) {
        my $status = status($tp);
        fatal "multiple statuses: $tp" if $status eq 'multiple';
        my $metrics = read_tape_metrics(basename($tp));
        my ($maxblocks, $blocksize) = @$metrics{qw(maxblocks blocksize)};
        my $capacity = size_human($maxblocks, $blocksize);
        my $tlogfh = xopen '<', "$tp/log";
        my ($tblk, $j, $b);
        my ($fnum, $endpos, $used) = (0, 0, 0);
        while (<$tlogfh>) {
            next if !/^(\d+) (\d+) (\S+) (\d+)/;
            ($fnum, $tblk, $j, $b) = ($1, $2, $3, $4);
        }
        if (defined $j) {
            my $jdir = jdir($j);
            my $jlog = read_log("$jdir/log");
            $endpos = $jlog->{'endpos'};
            $used = size_human($endpos, $blocksize);
        }
        printf "%-6.6s %-7.7s %8.8s %8.8s %7d %6.6s\n", basename($tp), $status, $capacity, $used, $fnum, sprintf('%.1f%%', 100-($endpos/$maxblocks*100));
    }
}

sub prog_eject {
    # Eject a tape
    init_defaults();
    fatal "No tape is loaded" if !defined $tape;
    eject_tape();
}

sub prog_load {
    # Load a tape
    my $eject;
    GetOptions(
        @common_options,
        'e|eject' => \$eject,
    ) or usage;
    init_defaults();
    usage if @ARGV > 1;
    my $newtape;
    if (@ARGV) {
        ($newtape) = @ARGV;
        if (defined $tape) {
            return if $newtape eq $tape;
            fatal "Tape $tape is loaded" if !$eject;
        }
    }
    if (defined $tape) {
        fatal "Tape $tape is loaded" if !$eject;
        eject_tape();
    }
    system(qw(tput civis));
    print STDERR "** Insert tape and press ENTER **";
    scalar <STDIN>;
    system(qw(tput cnorm));
    close mt('load') or fatal "load $!";
    close mt('lock') or fatal "lock $!";
    close mt('setblk', $block_size) or fatal "setblk $!";
    # Figure out which tape we've got
    eval { read_label() };
    if (!defined $label{label}) {
        print STDERR "This tape has not been labeled\n";
        fatal "cancelled" if !askbool('Label the tape?', 1);
        while (1) {
            $tape = ask('Enter a tape code:', $newtape);
            last if ! -e "$root/tape/$tape";
            print STDERR "That label is already in use\n";
        }
        my %metrics = (
            blocksize => ask('Block size:', DEFBLKSIZE),
            maxblocks => ask('Block count:', 76293945),  # LTO-6
        );
        init_tape(metrics => \%metrics);
    }
    elsif (defined $newtape) {
        fatal "That is not $newtape" if $tape ne $newtape;
    }
    set_status("$root/tape/$tape", 'offline' => 'loaded');
    unlink "$drive/tape" if -e "$drive/tape";
    xsymlink "../../tape/$tape", "$drive/tape";
}

# --- Functions

sub init_tape {
    my %meta = @_;
    my $metrics = $meta{metrics};
    xmkdir "$root/tape/$tape", "$root/tape/$tape/\@offline",;
    xopen '>', "$root/tape/$tape/log";
    write_tape_metrics($tape, %$metrics);
    %label = ( label => $tape );
    write_label();
}

sub eject_tape {
    close mt('unlock') or fatal "unlock: $!";
    close mt('eject')  or fatal "eject $!";
    if (-e "$drive/tape") {
        set_status("$drive/tape", 'loaded' => 'offline');
        xunlink "$drive/tape";
    }
    elsif (status("$root/tape/$tape") eq 'loaded') {
        set_status("$root/tape/$tape", 'loaded' => 'offline');
    }
}

sub askbool {
    -t STDIN || fatal "Interaction required but no TTY is available";
    my ($prompt, $yes_default) = @_;
    $prompt .= $yes_default ? " [Yn]" : " [yN]";
    print STDERR $prompt, ' ';
    my $answer = <STDIN>;
    while (!defined $answer || !length $answer) {
        return 1 if $yes_default;
        print STDERR $prompt, ' ';
        $answer = <STDIN>;
    }
    return 1 if $yes_default && $answer !~ /^[Nn]/;
    return $answer =~ /^[Yy]/;
}

sub ask {
    -t STDIN || fatal "Interaction required but no TTY is available";
    my ($prompt, $default) = @_;
    $prompt .= " [$default]" if defined $default;
    print STDERR $prompt, ' ';
    my $answer = <STDIN>;
    chomp $answer if defined $answer;
    while (!defined $answer || !length $answer) {
        return $default if defined $default;
        print STDERR $prompt, ' ';
        $answer = <STDIN>;
    }
    chomp $answer;
    return $answer;
}

sub size_human {
    my ($n, $b) = @_;
    my @sfx = ('', qw(K M G T P));
    my $m = 1;
    while (@_) {
        $m *= shift;
        while ($m >= 1024) {
            $m /= 1024;
            shift @sfx;
        }
    }
    return sprintf('%.1f%s', $m, $sfx[0]);
}

sub read_tape_metrics {
    my ($tp) = @_;
    my $tmetfh = xopen '<', "$root/tape/$tp/metrics";
    my %metrics;
    while (<$tmetfh>) {
        next if /^\s*(?:#.*)?$/;
        $metrics{$1} = $2 if /^(\S+)\s+(.+)/;
    }
    return \%metrics;
}

sub write_tape_metrics {
    my ($tp, %metrics) = @_;
    my $tmetfh = xopen '>', "$root/tape/$tp/metrics";
    foreach my $k (sort keys %metrics) {
        print $tmetfh "$k $metrics{$k}\n";
    }
}

sub read_block {
    my ($fh, $bufref) = @_;
    my $read = read($fh, $$bufref, $status{blocksize});
    fatal "read: $!" if !defined $read;
    return $read == $status{blocksize};
}

sub file_block_fwd {
    my ($num_blocks) = @_;
    my $fh = xopen('<', $device);
    my $buf;
    while ($num_blocks--) {
        read_block($fh, \$buf);
    }
}

sub jdir { "$root/job/" . shift }

sub xopen {
    my ($mode, $file) = @_;
    open my $fh, $mode, $file or fatal "open $mode $file: $!";
    return $fh;
}

sub xclose {
    close(shift) or fatal "close: $!";
}

sub xcat {
    my $outfh = pop @_;
    if (!ref $outfh) {
        $outfh = xopen pop(@_), $outfh;
    }
    foreach my $src (@_) {
        if (ref $src) {
            while (<$src>) {
                print $outfh $_;
            }
        }
        else {
            print $outfh $src;
        }
    }
    close $outfh;
}

sub xmkdir {
    foreach (@_) {
        mkdir $_ or fatal "mkdir: $_";
    }
}

sub xchdir {
    my ($dir) = @_;
    chdir $dir or fatal "chdir $dir: $!";
}

sub xmove {
    move($_[0], $_[1]) or fatal "move $_[0] $_[1]: $!";
}

sub xcopy {
    copy($_[0], $_[1]) or fatal "copy $_[0] $_[1]: $!";
}

sub xsymlink {
    symlink $_[0], $_[1] or fatal "symlink @_: $!";
}

sub xunlink {
    unlink $_[0] or fatal "unlink @_: $!";
}

sub read_job {
    my ($jfile) = @_;
    ($jfile) = glob("$jfile/?job") if $jfile !~ /job$/;
    my $type = substr(basename($jfile), 0, 1);
    fatal "read job: @_" if !defined $jfile;
    my $jfh = xopen '<', $jfile;
    my %job = ( file => $jfile, dir => dirname($jfile) );
    my @batches;
STANZA:
    while (<$jfh>) {
        if (/^%job$/) {
            while (<$jfh>) {
                last if /^$/;
                $job{$1} = $2 if /^(\S+) (.*)/;
            }
        }
        elsif (/^%batches$/) {
            while (<$jfh>) {
                last STANZA if /^$/;
                next if !/^(\d+) count (\d+) size (\d+)$/;
                push @batches, {
                    number => $1,
                    name => $type.$1,
                    count => $2,
                    size => $3,
                };
            }
        }
    }
    return (\%job, @batches) if wantarray;
    return \%job;
}

sub write_job {
    my ($jfile, $job, @batches) = @_;
    my %job = %$job;
    my $j = delete $job{job};
    my $jfh = xopen '>', $jfile;
    print $jfh <<"EOS";
%job
job $j
EOS
    print $jfh $_, ' ', $job{$_}, "\n" for sort keys %job;
    print $jfh "\n%batches\n";
    foreach (@batches) {
        my ($number, $count, $size) = @$_{qw(number count size)};
        print $jfh "$number count $count size $size\n";
    }
    close $jfh;
}

sub size_total {
    my $size = 0;
    foreach (@_) {
        next if ! -f;
        $size += -s _;
    }
    return $size;
}

sub read_log {
    my $jlogfh = xopen '<', shift;
    my (%file2loc, %tape, $tp, $fn, $pos, %time);
    while (<$jlogfh>) {
        if (/^F (\d+) (.+)/) {
            $file2loc{$2} = [ $tp, $fn, $1 ];
        }
        elsif (/^T (\S+) filenum (\d+)(?: position (\d+))?/) {
            $tape{$1} = 1;
            ($tp, $fn, $pos) = ($1, $2, $3);
        }
        elsif (/^J (\S+) (begin|end) (\d+)/) {
            $time{$2} = $3;
        }
    }
    return {
        begin => $time{begin},
        end => $time{end},
        tapes => [ keys %tape ],
        files => \%file2loc,
        endpos => $pos,
    }
}

sub usage {
    print STDERR "usage: $prog $_\n" if @_;
    print STDERR "usage: $prog [OPTION...] [ARG...]\n" if !@_;
    exit 1;
}

sub fatal {
    print STDERR "$prog: ", $_, "\n" for @_;
    die;
}

sub init_defaults {
    $drive //= readlink("$root/drive/default");
    $drive = "$root/drive/$drive" if $drive !~ m{^/};
    $device //= -e "$drive/device" ? "$drive/device" : '/dev/nst0';
    $block_size //= DEFBLKSIZE;
    my @loaded = grep { -d $_ } glob("$drive/tape/\@loaded");
    fatal "tape: multiple tapes loaded???" if @loaded > 1;
    $tape = basename(readlink dirname($loaded[0])) if @loaded;
    return if defined $queue && $queue =~ m{^/};
    $queue = defined $queue ? "$drive/queue/$queue" : "$drive/queue";
}

sub mt {
    open my $fh, '-|', 'mt', '-f', $device, @_ or fatal "mt: $!";
    return $fh;
}

sub tapeinfo {
    open my $fh, '-|', 'tapeinfo', '-f', $device or fatal "tapeinfo: $!";
    return $fh;
}

sub get_status {
    return %status = (
        filenum => 0,
        file_blocknum => 0,
        partition => 0,
        online => 1,
        eod => 1,
        eof => 0,
        bot => 1,
        blocksize => $block_size,
    ) if $dryrun;
    my $fh = mt('status');
    while (<$fh>) {
        $status{filenum}   = $1 if /file number[=: ]+([0-9]+)/i;
        $status{file_blocknum} = $1 if /block number[=: ]+(-?[0-9]+)/i;
        $status{partition} = $1 if /partition[=: ]+([0-9]+)/i;
        $status{online}    = 1  if /\bONLINE\b/i;
        $status{eod}       = 1  if /\bEOD\b/i;
        $status{eof}       = 1  if /\bEOF\b/i;
        $status{bot}       = 1  if /\bBOT\b/i;
        $status{blocksize} = $1 if /block size[=: ]+([0-9]+)/i;
    }
    close $fh or fatal "mt status: $!";
    $fh = tapeinfo();
    while (<$fh>) {
        $status{position}  = $1 if /block position[=: ]+([0-9]+)/i;
    }
    close $fh or fatal "tapeinfo: $!";
}

sub read_label {
    my ($f) = @_;
    if (!@_) {
        mt('rewind') or fatal "mt rewind: $!";
    }
    my $fh = xopen '<', $f // $device;
    my $read = read($fh, my $buf, $block_size)
        or fatal "read label: $!";
    close $fh;
    %label = ();
    if ($buf =~ /^\At0version:([0-9])\nlabel:([^\n\0]+)\n([^\0]*)\0*\z/) {
        %label = (
            t0version => $1,
            label => $2,
            map { split /:/, $_, 2 } split /\n/, $3
        );
    }
    my $sha256 = Digest->new('SHA-256');
    $sha256->add(substr($buf, 0, 2048));
    $label{hash} = $sha256->hexdigest;
    $tape //= $label{label} // 'hash='.$label{hash};
}

sub write_label {
    $tape = $label{label};
    my $fh;
    if (!$dryrun) {
        mt('rewind') or fatal "rewind: $!";
        $fh = xopen '>', $device;
    }
    my $buf = "\x00" x $block_size;
    my $str = sprintf("t0version:%d\nlabel:%s\ncreated:%s\n", T0VERSION, $tape, time);
    foreach (sort keys %label) {
        next if /^(label|t0version)$/;
        $str .= sprintf("%s:%s\n", $_, $label{$_});
    }
    substr($buf, 0, length $str) = $str;
    my $sha256 = Digest->new('SHA-256');
    $sha256->add($buf);
    my $hash = $sha256->hexdigest;
    if ($dryrun) {
        print STDERR "label that would be written (hash $hash):\n", $str;
    }
    else {
        syswrite($fh, $buf) or fatal "write: $!";
        xclose $fh;
        mt('weof') or fatal "weof: $!";
        xmkdir "$root/tape/$tape" if ! -e "$root/tape/$tape";
        $fh = xopen '>', "$root/tape/$tape/label";
        print $fh $str;
        return if !$verbose;
        print STDERR "label written: $tape (hash $hash)\n";
    }
}

sub read_manifest {
    my ($f) = @_;
    fatal "empty manifest: $f" if !-s $f;
    my $fh = xopen '<', $f;
    my @files = <$fh>;
    fatal "read manifest: $f" if !@files;
    chomp @files;
    return @files;
}

sub procwbatches {
    my ($job, @b) = @_;
    my $j = $job->{job};
    get_status();
    if (!$dryrun) {
        $status{online} or fatal "no tape\n";
        mt('eod');
        get_status();
        $status{eod} or fatal "not EOD\n";
        $job->{drive} = basename($drive);
        $job->{device} = $device;
    }
    my $jdir = jdir($j);
    my $jlogfh = $dryrun ? \*STDERR : xopen '>>', "$jdir/log";
    my $jfile = "$jdir/wjob";
    # cd job root
    my $cwd = cwd;
    my $dir = $job->{root} // '/';
    $dir =~ m{^/} or fatal "relative job root: $dir";
    printf $jlogfh "J %s begin %d\n", $j, time;
    xchdir $dir;
    foreach my $b (@b) {
        procwbatch($job, $jlogfh, "$jdir/$b");
    }
    get_status();
    xchdir $cwd;
    printf $jlogfh "J %s end %d\n", $j, time;
    printf $jlogfh "T %s filenum %d position %d\n", $tape // '?', @status{qw(filenum position)};
}

sub unique {
    my (%seen, @unique);
    foreach (@_) {
        push @unique, $_ if !$seen{$_}++;
    }
    return @unique;
}

sub read_batch {
    my ($f) = @_;
    my $b = basename($f);
    my @files;
    my %batch = (
        batch => $b,
        number => substr($b, 1),
        tape => '?',
        filenum => '?',
        errors => 0,
        files => \@files,
    );
    my $bfh = xopen '<', $f;
    while (<$bfh>) {
        next if /^%batch$/;
        last if /^$/;
        next if /^\s*(?:#.*)?$/;
        fatal "read batch file $f: unrecognized line: $_"
            if !/^(\S+) (.*)$/;
        $batch{$1} = $2;
    }
    while (<$bfh>) {
        next if /^%files$/;
        last if /^$/;
        chomp;
        push @files, $_;
    }
    $batch{tape} = $tape if defined $tape;
    return \%batch;
}

sub procwbatch {
    my ($job, $jlogfh, $bfile) = @_;
    my $jdir = dirname($bfile);
    my $batch = read_batch($bfile);
    my $n = $batch->{number};
    my ($afile, $wfile) = map { "$jdir/$_$n" } qw(@ w);

    # Build the manifest
    my @files;
    if ($dryrun) {
        push @files, $bfile;
    }
    else {
        # Rename bn ---> @n
        xmove $bfile, $afile;
        push @files, $afile;
    }
    push @files, "$jdir/wjob", @{ $batch->{files} };
    my $manifest = mktmp(manifest => @files);

    # Write the archive
    get_status();
    my ($filenum, $position) = @status{qw(filenum position)};
    my %fail = map { $_ => 1 } @files;
    printf $jlogfh "T %s filenum %d position %d\n", $tape // '?', $filenum, $position;
    printf $jlogfh "B %d begin %d files %d\n", $n, time, scalar(@files);
    open my $fhafio, "afio -o -A -b $block_size -v -B $device < $manifest 2>&1 |"
        or fatal "exec afio: $!";
    while (<$fhafio>) {
        if (/^([0-9]+) (.+) -- okay$/) {
            printf $jlogfh "F %d %s\n", $1, $2;
            delete $fail{$2};
        }
        else {
            print $jlogfh '* ', $_;
        }
    }
    unlink $manifest;
    close $fhafio or fatal "afio: $!";

    # Log any failed files
    print $jlogfh "E $_\n" for sort keys %fail;

    # Record in the tape log
    if (-d "$root/tape/$tape") {
        my $tlog = "$root/tape/$tape/log";
        my $tlogfh = xopen('>>', $tlog);
        my $j = $job->{job};
        print $tlogfh "$filenum $position $j $n\n";
    }

    # Rename @n ---> wn
    xmove $afile, $wfile if !$dryrun;
    printf $jlogfh "B %d end %d errors %d\n", $n, time, scalar keys %fail;
}

sub mktmp {
    my $type = shift;
    my $f = qx{mktemp -t t0p.$$.$type.XXXXXX};
    chomp $f;
    my $fh = xopen '>', $f;
    print $fh $_, "\n" for @_;
    close $fh;
    push @tmp, $f;
    return $f;
}

sub jobs {
    my @jobs;
    foreach (glob("$root/job/*/?job")) {
        my @parts = split '/';
        pop @parts;
        my $j = pop @parts;
        push @jobs, $j;
    }
    return @jobs;
}

sub jobs_in_queue {
    my @jobs;
    foreach my $j (jobs()) {
        push @jobs, $j if -e "$queue/$j";
    }
    return @jobs;
}

sub batches_in_job {
    my $job = shift;
    my %want = map { $_ => 1 } @_;
    %want = qw(b 1 r 1 w 1) if !@_;
    my %batch;
    foreach (glob("$job/*")) {
        next if !m{.+/([bwr])([0-9]+)$};
        $batch{$1.$2} = $1 if $want{$1};
    }
    return \%batch if !wantarray;
    return sort { substr($a, 1) <=> substr($b, 1) } keys %batch;
}

sub uuid {
    my $uuid = qx(uuidgen);
    chomp $uuid;
    return $uuid;
}

sub add_job_to_queue {
    my ($j) = @_;
    my $jdir = jdir($j);
    fatal "no such job: $j" if !-d $jdir;
    my @b = batches_in_job($jdir, 'b');
    fatal "no unprocessed batches in job $j" if !@b;
    xmkdir "$jdir/\@ready";
    xsymlink $jdir, "$queue/$j";
}

sub job_type {
    my ($j) = @_;
    my $jdir = jdir($j);
    return substr(basename(glob("$jdir/?job")), 0, 1);
}

sub clone_job {
    my ($oldj) = @_;
    my $oldjdir = jdir($oldj);
    my $oldstatus = status($oldjdir);
    $oldstatus eq 'done' || fatal "can't clone $oldj: not done";
    set_status($oldjdir, 'done' => 'cloning');
    my $type = job_type($oldj);
    my ($oldjob, @batches) = read_job("${oldjdir}/${type}job");
    my $j = uuid();
    my $jdir = jdir($j);
    xmkdir $jdir;
    my $jfile = "$jdir/${type}job";
    write_job($jfile, {
        %$oldjob,
        dir => $jdir,
        file => "${jdir}/${type}job",
        job => $j,
        cloned => time,
        'cloned-from' => $oldj,
    }, @batches);
    foreach my $batch (@batches) {
        my $number = $batch->{number};
        my $bfile = "$oldjdir/$type$number";
        fatal "No batch file: job $j batch $number" if !-e $bfile;
        xcopy($bfile, "$jdir/b$number");
    }
    set_status($oldjdir, 'cloning' => 'cloned');
    print $j, "\n";
}

sub revoke_job {
    my ($j) = @_;
    my $jdir = jdir($j);
    my $status = status($jdir);
    my $type = job_type($j);
    my $job = read_job("${jdir}/${type}job");
    if (-e $job->{receipt}) {
        set_status($jdir, '*' => 'revoked');
        xmove $job->{receipt}, "$jdir/\@revoked";
        print STDERR "revoked: $j\n";
    }
    elsif ($status ne 'revoked') {
        set_status($jdir, '*' => 'revoked');
        print STDERR "revoked: $j (no receipt)\n";
    }
    else {
        print STDERR "already revoked: $j\n";
    }
}
